<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel= "stylesheet" href ="https://kevinalexandertello.github.io/WDD330/notes.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kevin Tello's Home Page</title>
</head>
<body>
    <!--hola que ase-->
  <h1 style="text-align: center;">Welcome to Kevin Tello's Home Page</h1>
  <blockquote style="text-align: center;color: grey">
    “But I, being poor, have only my dreams;

    I have spread my dreams under your feet;
    
    Tread softly because you tread on my dreams.”</blockquote>
    
  <br>
  <hr>
  <h2>NOTES FROM WEEK 4</h2>
    


    <main>
        <div>
            <h1>Notes from JavaScript: Novice to Ninja, 2nd Edition </h1>
            <h2>Chapter 8: Forms</h2>
            <h3>
                ACCESSING FORM ELEMENTS
            </h3>
            <p>
                The legacy DOM had a useful property called document.forms that returns an HTML collection of all the forms in the document in the order they appear in the markup. Even though there is only one form in our example, a collection will still be returned, so we have to use index notation to return the first (and only) form object, like so:
                <br>
                const form = document.forms[0];

            </p>
            <p>
                A form object also has a method called elements that returns an HTML collection of all the elements contained in the form. In this case the form contains two controls: an input element and a button element:
<br>
const [input,button] = form.elements;
            </p>
            <p> we can use JavaScript to intercept the form before it’s sent by adding a submit event listener. 
            </p>
            <h2>Validate with Javascript  on the front</h2>
            <p>JavaScript validation should be used to enhance the user experience when filling in a form by giving feedback about any errors before it’s submitted. This should then be backed up with more validation performed on the server before the data is eventually saved to a database. Having said that, it’s still useful to validate on the client side even if the data will be validated again on the server side. This is because it will ensure that more valid data is sent to the server, which helps to cut down the number of HTTP requests required to send the form back and forward from the server to be corrected.</p>

            <h2>Chapter 12: Object-Oriented Programming in JavaScript</h2>
            <h3>
                
                Capitalizing Constructor Functions
            </h3>
By convention, the names of constructor functions or class declarations are capitalized, which is the convention used for classes in class-based programming languages.
            <p>When Parentheses Aren’t Required <br>
                The parentheses are not required when instantiating a new object using a constructor function. The following code would also achieve the same result:
                <br><br>
                const redDice = new Dice;<br> <br>
                                            
                The parentheses are required, however, if any default arguments need to be provided.
                <br>
                For example, if we want to create another Dice object with four sides, we would have to add 4 as an argument, like so:
                <br><br>
                const whiteDice = new Dice(4);</p>
                <h3>
                    Static Methods

                </h3>
                <p>

                    The static keyword can be used in class declarations to create a static method. These are sometimes called class methods in other programming languages. A static method is called by the class directly rather than by instances of the class.
                </p>
                <p>
                    Static methods are not available to instances of the class.
                </p>
                <h3>Public and Private Methods
                    </h3>
                    <p>
                        By default, an object’s methods are public in JavaScript. Methods and properties are said to be public because they can be queried directly and changed by assignment. The dynamic nature of the language means that an object’s properties and methods can be changed after it has been created.

                    </p>
                    <h3>Polymorphism</h3>
                    <p>
                        The concept of polymorphism means that different objects can have the same method, but implement it in different ways. The Object.prototype object has a toString() method that is shared by all objects. This means every object created in JavaScript will have a toString() method. Polymorphism means that objects are able to override this method with a more specific implementation. So although every object has a toString() method, the way it’s implemented can vary between different objects. For example, calling it on an array object will return each value in a comma-separated string:

                    </p>
                    <h3>Borrowing Methods from Prototypes</h3>
                    <p>
                        It’s possible to borrow methods from objects without having to inherit all their properties and methods. This is done by making a reference to the function that you want to borrow (that is, without parentheses so that it isn’t invoked).
                        
                        For example, the batman object doesn’t have any of the superpower methods that the superman object has, but we can create a reference to them that can then be used by another object. For example, we can create a fly() function by referencing the superman object’s fly method:
                        <br>
                        const fly = superman.fly;
                                   
                                        <br> 
                        This method can now be called on another object using the call method that all functions have, and that we learned about in Chapter 11:
                        
                        fly.call(batman); <br><br>
                       Up, up and away! Batman soars through the air!
                    </p>
                    <p>The call() method takes the object that the function is to be applied to as its first argument, then the usual arguments come afterwards.

                        The method can also be borrowed directly from an array literal, like so: <br>
                        
                        [].slice.call(arguments, 1, 3)</p>

                        <h4>Chapter Summary </h4>
                        <button id="btn"> show...</button>
                        <p> 
                            Object-oriented programming (OOP) is a way of programming that uses objects that encapsulate their own properties and methods.
                            <br>
                            The main concepts of OOP are encapsulation, polymorphism and inheritance.
                            <br>
                            Constructor functions can be used to create instances of objects.
                            <br>
                            ES6 introduced class declarations that use the class keyword. These can be used in place of constructor functions.
                            <br>
                            Inside a constructor function or class declaration, the keyword this refers to the object returned by the function.
                            <br>
                            All instances of a class or constructor function inherit all the properties and methods of its prototype.
                            <br>
                            The prototype is live, so new properties and methods can be added to existing instances.
                            <br>
                            The prototype chain is used to find an available method. If an object lacks a method, JavaScript will check whether its prototype has the method. If not, it will check that function’s prototype until it finds the method or reaches the Object constructor function.
                            <br>
                            Private properties and methods can be created by defining variables using const and defining a function inside a constructor function. These can be made public using getter and setter functions.
                            <br>
                            Monkey-patching is the process of adding methods to built-in objects by augmenting their prototypes. This should be done with caution as it can cause unexpected behavior in the way built-in objects work.
                            <br>
                            A mixin method can be used to add properties and methods from other objects without creating an inheritance chain.
                            <br>
                            Methods can be chained together and called in sequence if they return a reference to this.
                            <br>
                            Polymorphism allows objects to override shared methods with a more specific implementation.
                            <br>
                            The value of this is not retained inside nested functions, which can cause errors. This can be worked around by using that = this, using the bind(this) method and using arrow functions.
                            <br>
                            Methods can be borrowed from other objects.
                            <br>
                            Composition over inheritance is a design pattern where objects are composed from 'building-block' objects, rather than inheriting all their properties and methods from a parent class.</p>
        </div>
        <h2>Chapter 15: Modern JavaScript Development</h2>
        <h3>ADVANTAGES AND DISADVANTAGES OF LIBRARIES

        </h3>
        <p>
            There are some disadvantages to using libraries, however. You need to include the code for the library as well as your own code. This increases the amount of code that needs to be downloaded by a website, which in some cases can cause performance issues. Thankfully, most modern libraries are relatively small once server-side optimizations are made (such as gzip compression), minimizing any latency issues. <br> Another problem with libraries is that they might fail to implement the functionality in the precise way that you want it to perform. This might not be a problem, but sometimes you’ll have to get your hands dirty and write your own functions in order to achieve the functionality for which you are looking.

        </p>
        <span>It’s also advisable to consider that the popularity of a particular library can be 'here today, gone tomorrow'</span>
        
        <h3>MODULES</h3><p>If there are lots of values and functions that need to be imported, then everything in a module file can be imported using the wildcard symbol * along with a namespace for the imported values and functions using the following notation: <br>

            import * as stats from './stats.js';
            <br> <br>
                        
            This will then import all the functions from the stats.js module and they’ll be given a namespace of stats. So, the mean function could be used as follows:  <br> <br>
            
            stats.mean([2,6,10]);

        </p>
        <p>Default Exports
            Default exports refer to a single variable, function or class in a module that can be imported without having to be explicitly named. The syntax for default exports is purposely easier to read because this is how modules were designed to be used.  <br>
            
            The following example demonstrates how this would be done for a variable: <br> <br>
            
            const PI = 3.145926;<br> <br>
            
            export default PI;</p>
            <p>Don't Use More Than One Default Export <br>
                Having more than one default export will result in a syntax error.</p>
        <!-- <div>
            <h2>Questions</h2>
        </div> -->

    </main>

    
</body>
                       
  <h3>Code from my team in week 4
  </h3>
  <div>
      <a href ="https://kevinalexandertello.github.io/WDD330/teamweek04.html">Team week 4 assignment</a>
        <a href="https://kevinalexandertello.github.io/WDD330/wdd330indexforGIThub.html">Github Main menu portfolio</a>
  </div>

</body>
</html>
